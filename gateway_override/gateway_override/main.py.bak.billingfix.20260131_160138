import os
UPSTREAM_API_KEY = (os.getenv('R4_UPSTREAM_API_KEY') or '').strip()

import binascii
from typing import Optional

from fastapi import (
    FastAPI,
    Header,
    HTTPException,
    Depends,
    Request,
)
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, Response
from pydantic import BaseModel
import httpx

from eth_keys import keys
from eth_account import Account


# -------------------------------------------------------------------
# Config from environment
# -------------------------------------------------------------------

def _clean_env(name: str, default: str) -> str:
    raw = os.getenv(name, default)
    if raw is None:
        return default
    return raw.strip()


# –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º ‚Äî –ª–æ–∫–∞–ª–∫–∞; —É –ø—Ä–æ–¥—ñ –≤—Å–µ –æ–¥–Ω–æ –ø–µ—Ä–µ—ó–¥–µ –≤ ENV –∑ r4-prod
CORE_URL = _clean_env("CORE_URL", "http://localhost:8080").rstrip("/")
VRF_URL = _clean_env("VRF_URL", "http://localhost:8081").rstrip("/")

# –ü—É–±–ª—ñ—á–Ω–∏–π –∫–ª—é—á –¥–ª—è –∫–ª—ñ—î–Ω—Ç—ñ–≤ (X-API-Key / ?api_key=)
PUBLIC_API_KEY = _clean_env("PUBLIC_API_KEY", _clean_env("API_KEY", "demo"))
# –í–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –∫–ª—é—á –¥–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è –∑ gateway –¥–æ core/vrf
INTERNAL_R4_API_KEY = _clean_env("INTERNAL_R4_API_KEY", PUBLIC_API_KEY)

GATEWAY_VERSION = _clean_env("GATEWAY_VERSION", "v0.1.7")
LOG_LEVEL = _clean_env("LOG_LEVEL", "info")


# -------------------------------------------------------------------
# FastAPI app + CORS
# -------------------------------------------------------------------

# --- DEMO IP LIMITER (MVP) ---
import time
from datetime import datetime, timezone
from starlette.middleware.base import BaseHTTPMiddleware


# --- DEMO surface helper ---
def _is_demo_surface(request: Request) -> bool:
    path = request.url.path
    sig = (request.query_params.get("sig") or "").strip().lower()
    return (path == "/v1/random") or (path == "/v1/vrf" and sig == "ecdsa")

DEMO_ENABLED = (os.getenv("DEMO_ENABLED") or "0").strip() == "1"
DEMO_ALLOW_NO_KEY = (os.getenv("DEMO_ALLOW_NO_KEY") or "0").strip() == "1"
DEMO_KEY = (os.getenv("DEMO_KEY") or "demo").strip()

def _utc_day_str():
    return datetime.now(timezone.utc).strftime("%Y%m%d")

def _get_client_ip(request):
    # If behind Caddy, X-Forwarded-For should be set; take the first hop.
    xff = (request.headers.get("x-forwarded-for") or "").split(",")[0].strip()
    if xff:
        return xff
    return (request.client.host if request.client else "unknown")

# In-memory fallback (if redis client lib isn't installed in the gateway image)
_demo_mem_day = None
_demo_mem_uniq = set()
_demo_mem_last_ms = {}
_demo_mem_used = {}

async def _demo_check_limits(ip: str) -> None:
    """
    Enforce:
      - unique IPs/day cap
      - per-IP RPS (1 req / (1/ip_rps) sec)
      - per-IP daily quota
    Prefer Redis if available; fallback to in-memory if not.
    """
    unique_cap = int(os.getenv("DEMO_UNIQUE_IPS_PER_DAY") or "500")
    ip_daily = int(os.getenv("DEMO_IP_DAILY") or "30")
    ip_rps = float(os.getenv("DEMO_IP_RPS") or "1")

    # Try Redis first (shared across workers)
    try:
        import redis.asyncio as redis
        redis_url = (os.getenv("REDIS_URL") or "redis://r4-redis:6379/0").strip()
        r = redis.from_url(redis_url, decode_responses=True)

        day = _utc_day_str()

        uniq_key = f"demo:uniq:{day}"
        await r.sadd(uniq_key, ip)
        await r.expire(uniq_key, 36 * 3600)
        uniq = await r.scard(uniq_key)
        if uniq > unique_cap:
            raise HTTPException(status_code=429, detail="demo_unique_ip_cap")

        now_ms = int(time.time() * 1000)
        rps_key = f"demo:rps:{ip}"
        last = await r.get(rps_key)
        min_delta_ms = int(1000.0 / max(ip_rps, 0.001))
        if last is not None and (now_ms - int(last)) < min_delta_ms:
            raise HTTPException(status_code=429, detail="demo_rps")
        await r.setex(rps_key, 2, str(now_ms))

        q_key = f"demo:q:{day}:{ip}"
        used = await r.incr(q_key)
        if used == 1:
            await r.expire(q_key, 36 * 3600)
        if used > ip_daily:
            raise HTTPException(status_code=429, detail="demo_daily_quota")

        return
    except HTTPException:
        raise
    except Exception:
        # fallback to in-memory
        pass

    global _demo_mem_day, _demo_mem_uniq, _demo_mem_last_ms, _demo_mem_used
    day = _utc_day_str()
    if _demo_mem_day != day:
        _demo_mem_day = day
        _demo_mem_uniq = set()
        _demo_mem_last_ms = {}
        _demo_mem_used = {}

    _demo_mem_uniq.add(ip)
    if len(_demo_mem_uniq) > unique_cap:
        raise HTTPException(status_code=429, detail="demo_unique_ip_cap")

    now_ms = int(time.time() * 1000)
    last = _demo_mem_last_ms.get(ip)
    min_delta_ms = int(1000.0 / max(ip_rps, 0.001))
    if last is not None and (now_ms - last) < min_delta_ms:
        raise HTTPException(status_code=429, detail="demo_rps")
    _demo_mem_last_ms[ip] = now_ms

    used = _demo_mem_used.get(ip, 0) + 1
    _demo_mem_used[ip] = used
    if used > ip_daily:
        raise HTTPException(status_code=429, detail="demo_daily_quota")

class DemoIpLimiterMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        if not DEMO_ENABLED:
            return await call_next(request)

        path = request.url.path
        # demo surfaces only (adjust if needed)
        if not (path.startswith("/v1/random") or path.startswith("/v1/vrf")):
            return await call_next(request)

        api_key = (request.headers.get("x-api-key") or request.query_params.get("api_key") or "").strip()

        # Demo without key (homepage)
        if (not api_key) and DEMO_ALLOW_NO_KEY:
            ip = _get_client_ip(request)
            await _demo_check_limits(ip)
            return await call_next(request)

        # Explicit demo key
        if api_key == DEMO_KEY:
            ip = _get_client_ip(request)
            await _demo_check_limits(ip)
            return await call_next(request)

        return await call_next(request)

# -------------------------------------------------------------------
# DEMO per-surface daily limiter (per-IP, per-surface, UTC day)
# Surfaces:
#   - /v1/random                => "random"
#   - /v1/vrf?sig=ecdsa         => "vrf_ecdsa"
# DEMO qualifies when:
#   - X-API-Key == DEMO_KEY, OR
#   - no key AND DEMO_ALLOW_NO_KEY=1
# Limits:
#   DEMO_DAILY_RANDOM (default 5) and DEMO_DAILY_VRF_ECDSA (default 5)
# -------------------------------------------------------------------
from datetime import datetime, timezone, timedelta
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse

DEMO_ENABLED = (os.getenv("DEMO_ENABLED") or "0") == "1"
DEMO_KEY = (os.getenv("DEMO_KEY") or "demo").strip()
DEMO_ALLOW_NO_KEY = (os.getenv("DEMO_ALLOW_NO_KEY") or "0") == "1"

DEMO_DAILY_RANDOM = int(os.getenv("DEMO_DAILY_RANDOM") or "5")
DEMO_DAILY_VRF_ECDSA = int(os.getenv("DEMO_DAILY_VRF_ECDSA") or "5")

_demo_redis_client = None

def _demo_surface(request: Request):
    path = request.url.path
    if path == "/v1/random":
        return "random"
    if path == "/v1/vrf":
        sig = (request.query_params.get("sig") or "").strip().lower()
        if sig == "ecdsa":
            return "vrf_ecdsa"
    return None

def _demo_limit_for_surface(surf: str) -> int:
    if surf == "random":
        return DEMO_DAILY_RANDOM
    if surf == "vrf_ecdsa":
        return DEMO_DAILY_VRF_ECDSA
    return 5

def _demo_client_ip(request: Request) -> str:
    # trust X-Forwarded-For first hop (Caddy)
    xff = request.headers.get("x-forwarded-for", "")
    if xff:
        return xff.split(",")[0].strip()
    return (request.client.host if request.client else "").strip() or "unknown"

def _secs_until_utc_midnight() -> int:
    now = datetime.now(timezone.utc)
    nxt = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    return max(60, int((nxt - now).total_seconds()))

async def _get_demo_redis():
    global _demo_redis_client
    if _demo_redis_client is not None:
        return _demo_redis_client
    try:
        import redis.asyncio as redis
    except Exception:
        return None
    url = (os.getenv("REDIS_URL") or os.getenv("R4_REDIS_URL") or "redis://r4-redis:6379/0").strip()
    _demo_redis_client = redis.from_url(url, encoding="utf-8", decode_responses=True)
    return _demo_redis_client

class DemoSurfaceDailyLimiterMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # DEMO bypass billing (do NOT tie demo to billing service)
        try:
            surf = _demo_surface(request)
        except Exception:
            surf = None
        if DEMO_ENABLED and surf:
            hdr_key = (request.headers.get("x-api-key") or "").strip()
            qry_key = (request.query_params.get("api_key") or "").strip()
            k = (hdr_key or qry_key or "").strip()
            if (k == DEMO_KEY) or ((not k) and DEMO_ALLOW_NO_KEY):
                return await call_next(request)


        if not DEMO_ENABLED:
            return await call_next(request)

        surf = _demo_surface(request)
        if not surf:
            return await call_next(request)

        # demo key detection (header or ?api_key=)
        hdr_key = (request.headers.get("x-api-key") or "").strip()
        qry_key = (request.query_params.get("api_key") or "").strip()
        api_key = (hdr_key or qry_key or "").strip()

        # If a NON-demo key is present, it's not demo -> let normal auth/billing handle
        if api_key and api_key != DEMO_KEY:
            return await call_next(request)

        # If no key and demo-no-key disabled -> let normal auth/billing handle
        if (not api_key) and (not DEMO_ALLOW_NO_KEY):
            return await call_next(request)

        r = await _get_demo_redis()
        if r is None:
            # fail-open: don't crash gateway if redis isn't available
            return await call_next(request)

        ip = _demo_client_ip(request)
        day = datetime.now(timezone.utc).strftime("%Y%m%d")
        ttl = _secs_until_utc_midnight()
        limit = _demo_limit_for_surface(surf)

        k = f"r4:demo:{day}:{surf}:{ip}"
        n = await r.incr(k)
        if n == 1:
            await r.expire(k, ttl)

        if n > limit:
            return JSONResponse(
                {"ok": False, "detail": "demo_daily_limit", "surface": surf, "limit": limit},
                status_code=429,
            )

        return await call_next(request)



app = FastAPI()
app.add_middleware(DemoSurfaceDailyLimiterMiddleware)

app.add_middleware(DemoIpLimiterMiddleware)

# --- BILLING GUARD (MVP) ---
import httpx
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

BILLING_URL = (os.getenv("R4_BILLING_URL") or "http://r4-billing:8090").rstrip("/")
BILLING_GATE_PATH = "/gate/allow"

async def _billing_gate(api_key: str, path: str):
    url = f"{BILLING_URL}{BILLING_GATE_PATH}"
    timeout = httpx.Timeout(5.0, read=10.0)
    async with httpx.AsyncClient(timeout=timeout) as client:
        r = await client.post(url, json={"api_key": api_key, "path": path})
    if r.headers.get("content-type","").startswith("application/json"):
        return r.status_code, r.json()
    return r.status_code, {"detail":"billing_bad_response"}

class BillingGuardMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        path = request.url.path

        # Do not guard health + docs + webhook
        if path in ("/health", "/docs", "/openapi.json", "/api/v1/webhook/stripe"):
            return await call_next(request)

        # Guard only API surfaces (tweak if you want)
        if not (path.startswith("/v1/") or path.startswith("/api/v1/")):
            return await call_next(request)

        api_key = request.headers.get("x-api-key","").strip()
        if not api_key:
            # DEMO_BYPASS_MISSING_KEY_IN_BILLING_GUARD
            if (os.getenv("DEMO_ENABLED") or "0") == "1" and _is_demo_surface(request):
                demo_key = (os.getenv("DEMO_KEY") or "demo").strip()
                allow_no_key = (os.getenv("DEMO_ALLOW_NO_KEY") or "0") == "1"
                if allow_no_key and not api_key:
                    api_key = demo_key
            return JSONResponse({"detail":"missing_api_key"}, status_code=401)

        code, j = await _billing_gate(api_key, path)
        if code == 200 and j.get("ok") is True:
            return await call_next(request)

        # forward billing decision
        if code in (401,403,404,429):
            return JSONResponse(j, status_code=code)

        return JSONResponse({"detail":"billing_unavailable"}, status_code=503)

app.add_middleware(BillingGuardMiddleware)



# -------------------------------------------------------------------
# Middleware: service headers
# -------------------------------------------------------------------

@app.middleware("http")
async def add_svc_headers(request: Request, call_next):
    resp = await call_next(request)
    resp.headers["X-R4-Gateway-Version"] = GATEWAY_VERSION
    resp.headers["X-R4-Core-URL"] = CORE_URL
    resp.headers["X-R4-VRF-URL"] = VRF_URL
    return resp


# -------------------------------------------------------------------
# Simple API-key auth
# -------------------------------------------------------------------
async def require_api_key(
    request: Request,
    x_api_key: Optional[str] = Header(default=None, alias="X-API-Key"),
):
    """
    Dev auth:
      - header X-API-Key
      - or query ?api_key=...
      - allowlist from env R4_ALLOWED_KEYS (comma-separated)
        plus DEMO_API_KEY and PUBLIC_API_KEY for backwards-compat.
    """
    # R4_FIX_ALLOWED_INIT_V1
    # Ensure 'allowed' exists on all paths (avoid UnboundLocalError)
    allowed = set()
    
    # DEMO: allow no-key access by mapping to DEMO_KEY (only for demo surfaces)
    demo_enabled = (os.getenv('DEMO_ENABLED') or '0') == '1'
    demo_key = (os.getenv('DEMO_KEY') or 'demo').strip()
    demo_allow_no_key = (os.getenv('DEMO_ALLOW_NO_KEY') or '0') == '1'
    try:
        is_demo_surface = bool(globals().get('_is_demo_surface') and _is_demo_surface(request))
    except Exception:
        is_demo_surface = request.url.path in ('/v1/random','/v1/vrf')
    if demo_enabled and demo_allow_no_key and (not locals().get('api_key')) and is_demo_surface:
        api_key = demo_key
        # R4_FIX_DEMO_NO_KEY_V2
        # DEMO: allow no-key requests by mapping to DEMO_KEY (only for demo surfaces)
        demo_enabled = (os.getenv('DEMO_ENABLED') or '0') == '1'
        demo_key = (os.getenv('DEMO_KEY') or 'demo').strip()
        demo_allow_no_key = (os.getenv('DEMO_ALLOW_NO_KEY') or '0') == '1'
        try:
            is_demo_surface = bool(globals().get('_is_demo_surface') and _is_demo_surface(request))
        except Exception:
            is_demo_surface = request.url.path in ('/v1/random','/v1/vrf')
        if demo_enabled and demo_allow_no_key and is_demo_surface and (not api_key):
            api_key = demo_key
        
    
    # Always allow the demo key (so demo paths don't break)
    if demo_enabled and demo_key:
        allowed.add(demo_key)
    
    query_key = request.query_params.get("api_key")
    api_key = (x_api_key or query_key or "").strip()

    # DEMO no-key shortcut v2 (inline surface check)
    demo_enabled = (os.getenv("DEMO_ENABLED") or "0") == "1"
    demo_key = (os.getenv("DEMO_KEY") or "demo").strip()
    demo_allow_no_key = (os.getenv("DEMO_ALLOW_NO_KEY") or "0") == "1"

    # demo surfaces: /v1/random and /v1/vrf?sig=ecdsa
    path = request.url.path
    sig = (request.query_params.get("sig") or "").strip().lower()
    is_demo_surface = (path == "/v1/random") or (path == "/v1/vrf" and sig == "ecdsa")

    if demo_enabled and is_demo_surface and demo_key:
        if api_key == demo_key:
            return demo_key
        if (not locals().get('api_key')) and demo_allow_no_key:
            return demo_key

    # DEMO no-key shortcut (only for demo surfaces)
    demo_enabled = (os.getenv("DEMO_ENABLED") or "0") == "1"
    demo_key = (os.getenv("DEMO_KEY") or "demo").strip()
    demo_allow_no_key = (os.getenv("DEMO_ALLOW_NO_KEY") or "0") == "1"
    try:
        surf = _demo_surface(request)
    except Exception:
        surf = None

    if demo_enabled and surf:
        # allow explicit demo key
        if api_key == demo_key and demo_key:
            return demo_key
        # allow no-key demo if enabled
        if (not locals().get('api_key')) and demo_allow_no_key and demo_key:
            return demo_key

    # Always require a key to be present
    if not api_key:
        # DEMO_BYPASS_MISSING_KEY_IN_REQUIRE_API_KEY
        if (os.getenv("DEMO_ENABLED") or "0") == "1" and _is_demo_surface(request):
            demo_key = (os.getenv("DEMO_KEY") or "demo").strip()
            allow_no_key = (os.getenv("DEMO_ALLOW_NO_KEY") or "0") == "1"
            if allow_no_key and not api_key:
                return demo_key
        raise HTTPException(status_code=401, detail="missing_api_key")

    # Dev allowlist mode ONLY when env is non-empty.
    # In production we rely on billing/DB gate instead.
    raw = (os.getenv("R4_ALLOWED_KEYS") or "").strip()
    if raw:
        allowed = {k.strip() for k in raw.split(",") if k.strip()}

        demo = (os.getenv("DEMO_API_KEY") or "").strip()
        if demo:
            # FIX: ensure 'allowed' exists on all paths (avoid UnboundLocalError)
            allowed = set()
            allowed.add(demo)

    # allow DEMO_KEY too (separate from DEMO_API_KEY)
    demo_key = (os.getenv("DEMO_KEY") or "demo").strip()
    if demo_key:
        allowed.add(demo_key)

        # keep previous single-key behavior too
        try:
            allowed.add(PUBLIC_API_KEY)
        except Exception:
            pass

        if api_key not in allowed:
            # match billing-style semantics
            raise HTTPException(status_code=403, detail="unknown_key")

    return api_key


# -------------------------------------------------------------------
# Models
# -------------------------------------------------------------------

class VerifyRequest(BaseModel):
    msg_hash: str
    r: str
    s: str
    v: int
    expected_signer: str


# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------

HEX_CHARS = set("0123456789abcdef")


def _clean_hex_64(s: str, field: str) -> str:
    if s is None:
        raise HTTPException(status_code=400, detail=f"{field} is required")

    raw = s.strip().lower()
    if raw.startswith("0x"):
        raw = raw[2:]

    if len(raw) != 64 or any(c not in HEX_CHARS for c in raw):
        raise HTTPException(
            status_code=400,
            detail="msg_hash/r/s must be 64-hex (no 0x)",
        )
    return raw


def _normalize_v(v: int) -> int:
    if v in (27, 28):
        return v - 27
    if v in (0, 1):
        return v
    raise HTTPException(
        status_code=400,
        detail="v must be 0/1 or 27/28",
    )


def _normalize_address(addr: str) -> str:
    if not addr:
        return ""
    a = addr.strip()
    if not a.startswith("0x"):
        a = "0x" + a
    return a.lower()


# -------------------------------------------------------------------
# HTML landing page (—Ä–æ–∑—à–∏—Ä–µ–Ω–∞, ¬´—Ç–æ–≤—Å—Ç–∞¬ª –≤–µ—Ä—Å—ñ—è)
# -------------------------------------------------------------------

HOMEPAGE_HTML = """
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RE4CTOR SaaS API Gateway</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020817;
      --bg-2: #020617;
      --card: #020617;
      --accent1: #22c55e;
      --accent2: #06b6d4;
      --accent3: #facc15;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --error: #f97373;
      --ok: #22c55e;
      --font: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --mono: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: var(--font);
      background:
        radial-gradient(circle at 0% 0%, #1d283a 0%, rgba(15,23,42,0.05) 40%, transparent 60%),
        radial-gradient(circle at 100% 0%, #0f766e 0%, rgba(15,23,42,0.15) 35%, transparent 60%),
        radial-gradient(circle at 50% 100%, #1d283a 0%, rgba(2,6,23,0.9) 55%, #020617 100%);
      color: var(--text);
      min-height: 100vh;
    }
    a {
      color: inherit;
      text-decoration: none;
    }
    .page {
      max-width: 1180px;
      margin: 0 auto;
      padding: 28px 16px 72px;
    }
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 18px;
    }
    .logo-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .logo-mark {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      background:
        radial-gradient(circle at 30% 0%, #22c55e 0%, transparent 55%),
        radial-gradient(circle at 70% 90%, #06b6d4 0%, transparent 55%),
        #020617;
      border: 1px solid rgba(148,163,184,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: #e5e7eb;
      box-shadow: 0 0 18px rgba(34,197,94,0.25);
    }
    .logo-text-main {
      font-size: 15px;
      font-weight: 600;
    }
    .logo-text-sub {
      font-size: 11px;
      color: var(--muted);
    }
    .top-badge {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.3);
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
    }
    .pill-ok {
      padding: 2px 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      color: #020617;
      font-weight: 600;
      font-size: 11px;
    }
    .chip-row {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.3);
      font-size: 12px;
      margin-bottom: 18px;
    }
    .chip-pill {
      padding: 2px 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      color: #020617;
      font-weight: 600;
    }
    .chip-sub {
      color: var(--muted);
    }
    h1 {
      font-size: 34px;
      line-height: 1.1;
      margin: 0 0 8px;
    }
    .hero-sub {
      max-width: 620px;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.55;
      margin-bottom: 18px;
    }
    .hero-kpi-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 20px;
    }
    .hero-kpi {
      font-size: 12px;
      color: var(--muted);
    }
    .hero-kpi span {
      font-weight: 600;
      color: var(--text);
    }
    .hero-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 28px;
    }
    .btn-primary {
      border: none;
      outline: none;
      padding: 10px 20px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      color: #020617;
      box-shadow: 0 10px 30px rgba(34,197,94,0.25);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .btn-primary span.icon {
      font-size: 16px;
    }
    .btn-ghost {
      padding: 9px 18px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.6);
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 22px;
      font-size: 11px;
      color: var(--muted);
    }
    .badge-pill {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
    }
    .badge-pill strong {
      color: var(--text);
      font-weight: 600;
    }
    .layout-main {
      display: grid;
      grid-template-columns: minmax(0, 3.1fr) minmax(0, 2.3fr);
      gap: 26px;
      align-items: flex-start;
    }
    @media (max-width: 960px) {
      .layout-main {
        grid-template-columns: minmax(0,1fr);
      }
    }
    .section-title {
      font-size: 16px;
      font-weight: 600;
      margin: 22px 0 6px;
    }
    .section-sub {
      font-size: 13px;
      color: var(--muted);
      max-width: 640px;
      margin-bottom: 12px;
    }
    .playground-panel {
      border-radius: 18px;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(31,41,55,0.9);
      padding: 14px 14px 16px;
      box-shadow:
        0 18px 40px rgba(15,23,42,0.9),
        0 0 0 1px rgba(15,23,42,0.5) inset;
      position: relative;
    }
    .playground-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }
    .playground-title {
      font-size: 14px;
      font-weight: 600;
    }
    .playground-pill {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--muted);
    }
    .playground-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    .playground-input {
      flex: 1 1 220px;
      min-width: 0;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(31,41,55,1);
      background: rgba(2,6,23,0.95);
      color: var(--text);
      font-size: 13px;
      font-family: var(--mono);
    }
    .playground-input::placeholder {
      color: rgba(148,163,184,0.7);
    }
    .playground-btn {
      border-radius: 999px;
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      color: #020617;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .playground-btn.secondary {
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(148,163,184,0.6);
      color: var(--text);
    }
    .playground-btn span.icon {
      font-size: 15px;
    }
    .playground-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .playground-meta span.code {
      font-family: var(--mono);
      font-size: 11px;
      color: #e5e7eb;
    }
    .log-box {
      margin-top: 8px;
      border-radius: 12px;
      background: rgba(2,6,23,0.98);
      border: 1px solid rgba(31,41,55,1);
      padding: 8px;
      font-family: var(--mono);
      font-size: 11px;
      color: #e5e7eb;
      max-height: 230px;
      overflow: auto;
      white-space: pre;
    }
    .log-line-ok {
      color: var(--ok);
    }
    .log-line-err {
      color: var(--error);
    }
    .log-line-muted {
      color: var(--muted);
    }
    .snapshot-card {
      background:
        radial-gradient(circle at top left, rgba(34,197,94,0.18), transparent 52%),
        radial-gradient(circle at top right, rgba(56,189,248,0.14), transparent 55%),
        #020617;
      border-radius: 18px;
      padding: 14px 14px 16px;
      border: 1px solid rgba(148,163,184,0.35);
      box-shadow:
        0 16px 38px rgba(15,23,42,0.85),
        0 0 0 1px rgba(15,23,42,0.6) inset;
    }
    .snapshot-header {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .snapshot-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent1);
      box-shadow: 0 0 8px rgba(34,197,94,0.9);
    }
    .snapshot-sub {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .snapshot-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }
    .tag-pill {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--muted);
      background: rgba(15,23,42,0.9);
    }
    .tag-pill--accent {
      border: none;
      background: rgba(34,197,94,0.12);
      color: var(--accent1);
    }
    .tag-pill--pq {
      border: none;
      background: rgba(6,182,212,0.12);
      color: var(--accent2);
    }
    .snapshot-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-top: 6px;
    }
    @media (max-width: 520px) {
      .snapshot-grid {
        grid-template-columns: repeat(2, minmax(0,1fr));
      }
    }
    .snapshot-box {
      border-radius: 14px;
      padding: 9px 9px 10px;
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(31,41,55,1);
    }
    .snapshot-label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 2px;
    }
    .snapshot-value {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 1px;
    }
    .snapshot-meta {
      font-size: 11px;
      color: var(--muted);
    }
    .curl-card {
      background: rgba(15,23,42,0.98);
      border: 1px solid rgba(31,41,55,1);
      border-radius: 18px;
      padding: 12px 14px 14px;
      box-shadow:
        0 18px 30px rgba(15,23,42,0.9),
        0 0 0 1px rgba(15,23,42,0.7) inset;
      font-family: var(--mono);
      font-size: 11px;
      color: #e5e7eb;
      margin-top: 16px;
    }
    .curl-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--muted);
    }
    .curl-badge {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
    }
    .curl-pre {
      white-space: pre;
      overflow-x: auto;
    }
    .curl-pre span.url {
      color: #93c5fd;
    }
    .muted {
      color: var(--muted);
    }
    .footer {
      margin-top: 26px;
      font-size: 11px;
      color: var(--muted);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: space-between;
    }
    .footer span.code {
      font-family: var(--mono);
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="top-row">
      <div class="logo-row">
        <div class="logo-mark">R4</div>
        <div>
          <div class="logo-text-main">RE4CTOR Gateway</div>
          <div class="logo-text-sub">Entropy ‚Üí VRF ‚Üí Proofs</div>
        </div>
      </div>
      <div class="top-badge">
        <span class="pill-ok">dev mode</span>
        <span>Public demo key: <span class="code">demo</span></span>
      </div>
    </div>

    <div class="chip-row">
      <span class="chip-pill">RE4CTOR SaaS API</span>
      <span class="chip-sub">30‚Äì50ms latency ‚Ä¢ 600√ó faster than on-chain oracles ‚Ä¢ dual-signed entropy</span>
    </div>

    <h1>FIPS-ready randomness API with verifiable proofs.</h1>
    <p class="hero-sub">
      RE4CTOR SaaS API is a hardened HTTP gateway in front of RE4CTOR Core RNG
      and dual-signature VRF (ECDSA + ML-DSA-65). One endpoint for crypto, gaming,
      and defense workloads that demand auditable entropy.
    </p>

    <div class="hero-kpi-row">
      <div class="hero-kpi"><span>20‚Äì30 ms</span> end-to-end in dev</div>
      <div class="hero-kpi"><span>NIST SP800-22</span> tested core streams</div>
      <div class="hero-kpi"><span>ML-DSA-65</span> post-quantum VRF proofs</div>
    </div>

    <div class="hero-actions">
      <button id="btn-try-api" class="btn-primary">
        <span class="icon">‚ñ∂</span>
        <span>Try live API</span>
      </button>
      <button id="btn-open-docs" class="btn-ghost">
        <span class="icon">‚ò∞</span>
        <span>Open Swagger <span class="code">/docs</span></span>
      </button>
    </div>

    <div class="badge-row">
      <div class="badge-pill"><strong>Core:</strong> 256-bit entropy, mixed &amp; whitened</div>
      <div class="badge-pill"><strong>VRF:</strong> ECDSA(secp256k1) + ML-DSA-65</div>
      <div class="badge-pill"><strong>Headers:</strong> <span class="code">X-R4-*</span> expose runtime</div>
    </div>

    <div class="layout-main">
      <div>
        <div class="section-title">Live API playground</div>
        <p class="section-sub">
          Use this gateway directly from your browser. Calls go to
          <span class="muted" id="runtime-base-label">your gateway</span> and show live responses.
          Public dev key: <span class="code">demo</span>.
        </p>

        <div class="playground-panel">
          <div class="playground-header-row">
            <div class="playground-title">Gateway configuration</div>
            <div class="playground-pill">
              Base URL &middot; X-API-Key &middot; Latency
            </div>
          </div>

          <div class="playground-row">
            <input
              id="base-url-input"
              type="text"
              class="playground-input"
              value=""
              placeholder="https://api.re4ctor.com"
            />
            <input
              id="api-key-input"
              type="text"
              class="playground-input"
              style="max-width: 200px"
              value="demo"
              placeholder="API key (X-API-Key)"
            />
          </div>

          <div class="playground-row">
            <button id="btn-call-random" class="playground-btn">
              <span class="icon">üé≤</span>
              <span>Call /v1/random</span>
            </button>
            <button id="btn-call-vrf" class="playground-btn secondary">
              <span class="icon">üîê</span>
              <span>Call /v1/vrf?sig=ecdsa</span>
            </button>
            <button id="btn-call-dual-full" class="playground-btn secondary">
              <span class="icon">üß¨</span>
              <span>/v1/random_dual_full?sig=dual</span>
            </button>
          </div>

          <div class="playground-meta">
            <span>Latency: <span id="latency-value" class="code">‚Äî</span></span>
            <span>Core: <span class="code">/random</span></span>
            <span>VRF: <span class="code">/random_dual</span></span>
          </div>

          <div id="log-box" class="log-box">
Ready. Click ‚ÄúCall /v1/random‚Äù, ‚ÄúCall /v1/vrf?sig=ecdsa‚Äù or ‚Äú/v1/random_dual_full?sig=dual‚Äù.
          </div>
        </div>
      </div>

      <div>
        <div class="snapshot-card">
          <div class="snapshot-header">
            <div class="snapshot-dot"></div>
            <span>Runtime snapshot</span>
          </div>
          <div class="snapshot-sub">
            Live view into your RE4CTOR gateway. Values are returned via HTTP and <span class="code">X-R4-*</span> headers.
          </div>

          <div class="snapshot-tags">
            <div class="tag-pill tag-pill--accent">FIPS 204-ready üîê</div>
            <div class="tag-pill tag-pill--pq">Post-quantum combo (ML-DSA-65)</div>
            <div class="tag-pill">On-chain proof friendly</div>
          </div>

          <div class="snapshot-grid">
            <div class="snapshot-box">
              <div class="snapshot-label">Latency (dev)</div>
              <div id="latency-value-2" class="snapshot-value">‚Äî</div>
              <div class="snapshot-meta">Gateway ‚Üí Core</div>
            </div>
            <div class="snapshot-box">
              <div class="snapshot-label">VRF mode</div>
              <div class="snapshot-value">ECDSA + ML-DSA-65</div>
              <div class="snapshot-meta">Dual-signed</div>
            </div>
            <div class="snapshot-box">
              <div class="snapshot-label">Plan</div>
              <div class="snapshot-value">dev</div>
              <div class="snapshot-meta">X-API-Key: demo</div>
            </div>
          </div>
        </div>

        <div class="curl-card">
          <div class="curl-header">
            <span>curl examples</span>
            <span class="curl-badge">copy &amp; paste into terminal</span>
          </div>
          <div class="curl-pre">
curl -s -H "X-API-Key: demo" \\
  "<span id="curl-base-url-1" class="url">https://api.re4ctor.com</span>/v1/random?n=16&fmt=hex"

curl -s -H "X-API-Key: demo" \\
  "<span id="curl-base-url-2" class="url">https://api.re4ctor.com</span>/v1/vrf?sig=ecdsa" | jq .

curl -s -H "X-API-Key: demo" \\
  "<span id="curl-base-url-3" class="url">https://api.re4ctor.com</span>/v1/random_dual_full?sig=dual" | jq .
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <span>Gateway: <span class="code">FastAPI</span> ‚Ä¢ Core / VRF: <span class="code">RE4CTOR</span></span>
      <span>Check <span class="code">/v1/meta</span> and <span class="code">/v1/env_debug</span> for introspection.</span>
    </div>
  </div>

  <script>
    (function() {
      function byId(id) { return document.getElementById(id); }

      var baseInput      = byId("base-url-input");
      var apiKeyInput    = byId("api-key-input");
      var logBox         = byId("log-box");
      var latencyValue   = byId("latency-value");
      var latencyValue2  = byId("latency-value-2");
      var runtimeLabel   = byId("runtime-base-label");
      var curlBase1      = byId("curl-base-url-1");
      var curlBase2      = byId("curl-base-url-2");
      var curlBase3      = byId("curl-base-url-3");

      var origin = window.location.origin || "";

      if (baseInput && !baseInput.value) {
        baseInput.value = origin || "https://api.re4ctor.com";
      }
      if (runtimeLabel) {
        runtimeLabel.textContent = origin || "your gateway";
      }
      if (curlBase1 && origin) curlBase1.textContent = origin;
      if (curlBase2 && origin) curlBase2.textContent = origin;
      if (curlBase3 && origin) curlBase3.textContent = origin;

      function appendLog(line, cls) {
        if (!logBox) return;
        var span = document.createElement("span");
        if (cls) span.className = cls;
        span.textContent = line + "\\n";
        logBox.appendChild(span);
        logBox.scrollTop = logBox.scrollHeight;
      }

      function setLatency(ms) {
        var txt = ms + " ms";
        if (latencyValue) latencyValue.textContent = txt;
        if (latencyValue2) latencyValue2.textContent = txt;
      }

      async function callEndpoint(path) {
        var base = (baseInput && baseInput.value.trim()) || origin || "https://api.re4ctor.com";
        var key  = (apiKeyInput && apiKeyInput.value.trim()) || "demo";

        if (!base) {
          appendLog("ERROR: base URL is empty", "log-line-err");
          return;
        }
        if (!base.startsWith("http")) {
          base = "https://" + base;
        }
        var url = base.replace(/\\/$/, "") + path;

        var t0 = performance.now();
        appendLog("‚Üí GET " + url, "log-line-muted");
        try {
          var res = await fetch(url, {
            method: "GET",
            headers: { "X-API-Key": key }
          });
          var dt = Math.round(performance.now() - t0);
          setLatency(dt);

          var text = await res.text();
          if (res.ok) {
            appendLog("‚Üê " + res.status + " OK (" + dt + " ms)", "log-line-ok");
            appendLog(text, "log-line-muted");
          } else {
            appendLog("‚Üê " + res.status + " ERROR (" + dt + " ms)", "log-line-err");
            appendLog(text, "log-line-err");
          }
        } catch (e) {
          appendLog("ERROR: " + (e && e.message ? e.message : e), "log-line-err");
        }
      }

      var btnRandom    = byId("btn-call-random");
      var btnVrf       = byId("btn-call-vrf");
      var btnDualFull  = byId("btn-call-dual-full");
      var btnTry       = byId("btn-try-api");
      var btnDocs      = byId("btn-open-docs");

      if (btnRandom) {
        btnRandom.addEventListener("click", function() {
          callEndpoint("/v1/random?n=16&fmt=hex");
        });
      }
      if (btnVrf) {
        btnVrf.addEventListener("click", function() {
          callEndpoint("/v1/vrf?sig=ecdsa");
        });
      }
      if (btnDualFull) {
        btnDualFull.addEventListener("click", function() {
          callEndpoint("/v1/random_dual_full?sig=dual");
        });
      }
      if (btnTry) {
        btnTry.addEventListener("click", function() {
          callEndpoint("/v1/random?n=16&fmt=hex");
        });
      }
      if (btnDocs) {
        btnDocs.addEventListener("click", function() {
          var base = (baseInput && baseInput.value.trim()) || origin || "https://api.re4ctor.com";
          if (!base.startsWith("http")) base = "https://" + base;
          window.open(base.replace(/\\/$/, "") + "/docs", "_blank");
        });
      }
    })();
  </script>
</body>
</html>
"""


# -------------------------------------------------------------------
# Routes
# -------------------------------------------------------------------

@app.get("/", response_class=HTMLResponse)
async def landing_page():
    return HTMLResponse(content=HOMEPAGE_HTML)


@app.get("/v1/health")
async def health():
    return {"ok": True}


@app.get("/v1/meta")
async def meta():
    return {
        "gateway_version": GATEWAY_VERSION,
        "core_url": CORE_URL,
        "vrf_url": VRF_URL,
    }


@app.get("/v1/env_debug")
async def env_debug():
    return {
        "CORE_URL": CORE_URL,
        "VRF_URL": VRF_URL,
        "PUBLIC_API_KEY": PUBLIC_API_KEY,
        "INTERNAL_R4_API_KEY": INTERNAL_R4_API_KEY,
        "GATEWAY_VERSION": GATEWAY_VERSION,
    }


@app.get("/v1/random")
async def random_proxy(
    n: int,
    fmt: str = "hex",
    api_key: str = Depends(require_api_key),
):
    upstream = f"{CORE_URL}/random"
    params = {"n": n, "fmt": fmt}
    if UPSTREAM_API_KEY:
        params["key"] = UPSTREAM_API_KEY
    headers = {}

    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            r = await client.get(upstream, params=params, headers=headers)
    except httpx.HTTPError as e:
        raise HTTPException(status_code=502, detail=f"core_unreachable: {e!s}")

    return Response(
        content=r.content,
        status_code=r.status_code,
        media_type=r.headers.get("content-type", "text/plain"),
    )


@app.get("/v1/vrf")
async def vrf_proxy(
    sig: str,
    api_key: str = Depends(require_api_key),
):
    upstream = f"{VRF_URL}/random_dual"
    params = {"sig": sig}
    headers = {"X-API-Key": (UPSTREAM_API_KEY or INTERNAL_R4_API_KEY)}
    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            r = await client.get(upstream, params=params, headers=headers)
    except httpx.HTTPError as e:
        raise HTTPException(status_code=502, detail=f"vrf_unreachable: {e!s}")

    return Response(
        content=r.content,
        status_code=r.status_code,
        media_type=r.headers.get("content-type", "application/json"),
    )


@app.get("/v1/random_dual")
async def random_dual_proxy(
    sig: str,
    api_key: str = Depends(require_api_key),
):
    """
    Alias –¥–æ —Ç–æ–≥–æ –∂ –±–µ–∫–µ–Ω–¥—É, —â–æ –π /v1/vrf ‚Äì –∫–æ—Ä–æ—Ç–∫–∏–π —à–ª—è—Ö –¥–ª—è dual-sig VRF.
    """
    upstream = f"{VRF_URL}/random_dual"
    params = {"sig": sig}
    headers = {"X-API-Key": (UPSTREAM_API_KEY or INTERNAL_R4_API_KEY)}
    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            r = await client.get(upstream, params=params, headers=headers)
    except httpx.HTTPError as e:
        raise HTTPException(status_code=502, detail=f"vrf_unreachable: {e!s}")

    return Response(
        content=r.content,
        status_code=r.status_code,
        media_type=r.headers.get("content-type", "application/json"),
    )


@app.get("/v1/random_dual_full")
async def random_dual_full_proxy(
    sig: str,
    api_key: str = Depends(require_api_key),
):
    """
    –ü–æ–≤–Ω–∏–π dual-sig –æ–±'—î–∫—Ç —ñ–∑ VRF –Ω–æ–¥–∏:
    - random
    - msg_hash
    - ECDSA (v,r,s)
    - ML-DSA-65 sig (base64)
    - PQ public key
    """
    upstream = f"{VRF_URL}/random_dual_full"
    params = {"sig": sig}
    headers = {"X-API-Key": (UPSTREAM_API_KEY or INTERNAL_R4_API_KEY)}
    try:
        async with httpx.AsyncClient(timeout=20.0) as client:
            r = await client.get(upstream, params=params, headers=headers)
    except httpx.HTTPError as e:
        raise HTTPException(status_code=502, detail=f"vrf_unreachable: {e!s}")

    return Response(
        content=r.content,
        status_code=r.status_code,
        media_type=r.headers.get("content-type", "application/json"),
    )


@app.post("/v1/verify")
async def verify_signature(req: VerifyRequest):
    """
    –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ ECDSA –ø—ñ–¥–ø–∏—Å—É (secp256k1) –ø–æ –≤–∂–µ –≥–æ—Ç–æ–≤–æ–º—É msg_hash (32 –±–∞–π—Ç–∏).
    msg_hash, r, s ‚Äì —É hex (–∑ 0x –∞–±–æ –±–µ–∑), v ‚Äì 0/1 –∞–±–æ 27/28.
    expected_signer ‚Äì –æ—á—ñ–∫—É–≤–∞–Ω–∞ –∞–¥—Ä–µ—Å–∞ "0x..." (—á—É—Ç–ª–∏–≤–∞ –¥–æ checksum / –Ω—ñ ‚Äì –Ω–µ –≤–∞–∂–ª–∏–≤–æ).
    """
    msg_hex = _clean_hex_64(req.msg_hash, "msg_hash")
    r_hex = _clean_hex_64(req.r, "r")
    s_hex = _clean_hex_64(req.s, "s")
    v_norm = _normalize_v(req.v)

    try:
        msg_bytes = binascii.unhexlify(msg_hex)
    except binascii.Error as e:
        raise HTTPException(
            status_code=400,
            detail=f"invalid msg_hash hex: {e}",
        )

    r_int = int(r_hex, 16)
    s_int = int(s_hex, 16)

    try:
        sig = keys.Signature(vrs=(v_norm, r_int, s_int))
    except Exception as e:
        raise HTTPException(
            status_code=400,
            detail=f"signature_init_failed: {type(e).__name__}: {e}",
        )

    try:
        recovered = Account.recover_hash(msg_bytes, signature=sig.to_bytes())
    except Exception as e:
        raise HTTPException(
            status_code=400,
            detail=f"recover_failed: {type(e).__name__}: {e}",
        )

    recovered_norm = _normalize_address(recovered)
    expected_norm = _normalize_address(req.expected_signer)
    match = recovered_norm == expected_norm

    return {
        "ok": True,
        "match": match,
        "recovered": recovered,
        "expected": req.expected_signer,
        "v_used": v_norm,
    }

# --- STRIPE WEBHOOK (PROXY -> r4-billing) ---
from fastapi import Request

BILLING_URL = (os.getenv("R4_BILLING_URL") or "http://r4-billing:8090").rstrip("/")
BILLING_WEBHOOK_PATH = "/webhook/stripe"

# --- STRIPE WEBHOOK (MVP) ---
from fastapi import Request
from fastapi.responses import JSONResponse
import httpx

BILLING_URL = (os.getenv("R4_BILLING_URL") or "http://r4-billing:8090").rstrip("/")
BILLING_WEBHOOK_PATH = "/webhook/stripe"

@app.post("/api/v1/webhook/stripe")
async def stripe_webhook(req: Request):
    raw = await req.body()
    sig = req.headers.get("stripe-signature") or req.headers.get("Stripe-Signature") or ""

    if not sig:
        return JSONResponse({"detail":"stripe_signature_missing"}, status_code=400)

    url = f"{BILLING_URL}{BILLING_WEBHOOK_PATH}"
    timeout = httpx.Timeout(10.0, read=20.0)

    async with httpx.AsyncClient(timeout=timeout) as client:
        r = await client.post(
            url,
            content=raw,
            headers={
                "Stripe-Signature": sig,
                "Content-Type": req.headers.get("content-type","application/json"),
            },
        )

    ctype = r.headers.get("content-type","")
    if ctype.startswith("application/json"):
        return JSONResponse(r.json(), status_code=r.status_code)
    return JSONResponse({"detail":"billing_non_json","status_code": r.status_code}, status_code=502)

